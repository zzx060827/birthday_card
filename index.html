<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一份特别的祝福</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Lato:wght@400;700&family=Great+Vibes&family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <style>
        /* --- 基础和背景样式 --- */
        body {
            background-color: #0c1445;
            perspective: 1000px;
            overflow: hidden;
            cursor: none;
        }

        .font-serif {
            font-family: 'Playfair Display', serif;
        }
        .font-sans {
            font-family: 'Lato', sans-serif;
        }
        .font-cursive {
            font-family: 'Great Vibes', cursive;
        }
        .font-chinese {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 1.5em;
            line-height: 1.6;
        }

        /* --- 卡片翻转样式 --- */
        .card-container {
            width: 350px;
            height: 500px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            cursor: pointer;
            z-index: 10;
        }
        .card-container.is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            text-align: center;
            border: 2px solid rgba(255, 215, 0, 0.5);
            background-color: rgba(28, 42, 143, 0.5);
            backdrop-filter: blur(5px);
        }
        .card-front {
            z-index: 2;
        }
        .card-back {
            transform: rotateY(180deg);
        }

        /* --- 效果Canvas和背景星星 --- */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 8;
        }
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <!-- 这个Canvas专门用来显示背景图，位于最底层 -->
    <canvas id="background-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;"></canvas>
    
    <!-- 闪烁的星星容器 -->
    <div id="stars-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;"></div>
    
    <!-- 祝福卡片 -->
    <div id="card" class="card-container">
        <div class="card-face card-front">
            <h1 class="font-serif text-4xl font-bold text-white mb-4">To: <span class="font-chinese">郭丹妮</span></h1>
            <p class="font-sans text-yellow-200 mt-2 text-lg">A Magical Birthday Wish</p>
            <p class="mt-8 text-yellow-400 opacity-75 animate-pulse font-sans">（点击开启）</p>
        </div>
        <div class="card-face card-back">
            <h2 class="font-cursive text-5xl font-bold text-yellow-300 mb-4" style="text-shadow: 2px 2px 5px rgba(0,0,0,0.5);">Happy 18th Birthday</h2>
            <p class="font-chinese mt-4 text-gray-200 text-left leading-relaxed">
                To 郭丹妮,<br>
                愿所有的梦想都会实现，<br>
                未来的旅途，愿你步履坚定，永远被爱与温暖环绕。
                <br>
                我会永远支持你的人生抉择。
            </p>
            <p class="mt-6 text-right w-full font-bold text-yellow-300 font-chinese">朱子轩</p>
        </div>
    </div>

    <!-- 这个Canvas专门用于粒子效果（烟花和鼠标拖尾），位于背景图和星星之上，但在卡片之下 -->
    <canvas id="particle-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 8;"></canvas>

    <script>
        const card = document.getElementById('card');
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');
        const starsContainer = document.getElementById('stars-container');
        const backgroundCanvas = document.getElementById('background-canvas');
        const backgroundCtx = backgroundCanvas.getContext('2d');
        let particles = [];
        const colors = ['#FFD700', '#FF69B4', '#00BFFF', '#98FB98', '#FF6347', '#BA55D3', '#FFFFFF'];
        let backgroundImage = new Image();
        
        // 【重要】已将图片替换为在线占位图，你可以换回自己的 'castle.jpg' 路径
        backgroundImage.src = 'castle.jpg';
        backgroundImage.onerror = function() {
            // 如果图片加载失败，提供一个备用方案
            console.error("Background image failed to load.");
            backgroundCanvas.style.backgroundColor = '#0c1445';
        };


        function setupCanvas() {
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            drawBackground();
        }
        window.addEventListener('resize', setupCanvas);

        function drawBackground() {
            // 确保图片完全覆盖画布
            const hRatio = backgroundCanvas.width / backgroundImage.width;
            const vRatio = backgroundCanvas.height / backgroundImage.height;
            const ratio = Math.max(hRatio, vRatio);
            const centerShift_x = (backgroundCanvas.width - backgroundImage.width * ratio) / 2;
            const centerShift_y = (backgroundCanvas.height - backgroundImage.height * ratio) / 2;
            backgroundCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            backgroundCtx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height,
                centerShift_x, centerShift_y, backgroundImage.width * ratio, backgroundImage.height * ratio);
        }

        backgroundImage.onload = function() {
            setupCanvas();
        };

        function createStars() {
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        card.addEventListener('click', function() {
            if (!card.classList.contains('is-flipped')) {
                card.classList.add('is-flipped');
                launchDisneyFireworks();
            }
        });

        window.addEventListener('mousemove', function(e) {
            for (let i = 0; i < 5; i++) {
                particles.push(createTrailParticle(e.clientX, e.clientY));
            }
        });

        function launchDisneyFireworks() {
            const fireworkCount = 30;
            for (let i = 0; i < fireworkCount; i++) {
                setTimeout(() => {
                    let x;
                    if (Math.random() < 0.5) {
                        x = Math.random() * window.innerWidth * 0.35;
                    } else {
                        x = window.innerWidth * 0.65 + Math.random() * window.innerWidth * 0.35;
                    }
                    const y = window.innerHeight * 1.5;
                    launchSingleFirework(x, y);
                }, i * 300);
            }
        }

        function launchSingleFirework(x, y) {
            const rocketParticle = {
                x: x, y: y,
                velocityX: (Math.random() - 0.5) * 2,
                velocityY: -Math.random() * 15 - 12,
                size: 3, color: '#FFFFFF',
                gravity: 0.15, drag: 0.99,
                opacity: 1, fade: 0,
                isRocket: true, exploded: false,
                explode: function() {
                    const explosionParticles = 250;
                    const baseHue = Math.random() * 360;
                    for (let i = 0; i < explosionParticles; i++) {
                        const type = Math.random();
                        if (type < 0.7) {
                            particles.push(createExplosionParticle(this.x, this.y, baseHue));
                        } else if (type < 0.9) {
                            particles.push(createGlitterParticle(this.x, this.y));
                        } else {
                            particles.push(createCrackleParticle(this.x, this.y, baseHue));
                        }
                    }
                }
            };
            particles.push(rocketParticle);
        }

        function createExplosionParticle(x, y, baseHue) {
            const particle = {};
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 10 + 2;
            particle.x = x; particle.y = y;
            particle.velocityX = speed * Math.cos(angle);
            particle.velocityY = speed * Math.sin(angle);
            particle.size = Math.random() * 3 + 1;
            const hue = baseHue + (Math.random() - 0.5) * 40;
            const lightness = Math.random() * 20 + 50;
            particle.color = `hsl(${hue}, 100%, ${lightness}%)`;
            particle.gravity = 0.1; particle.drag = 0.96;
            particle.opacity = 1;
            particle.fade = Math.random() * 0.02 + 0.01;
            return particle;
        }

        function createGlitterParticle(x, y) {
            const particle = createExplosionParticle(x, y, 0);
            particle.color = '#FFFFFF';
            particle.size = Math.random() * 2 + 0.5;
            particle.drag = 0.92;
            particle.fade = Math.random() * 0.05 + 0.02;
            return particle;
        }

        function createCrackleParticle(x, y, baseHue) {
            const particle = createExplosionParticle(x, y, baseHue);
            particle.size = Math.random() * 4 + 2;
            particle.drag = 0.98;
            particle.isCrackle = true;
            particle.crackleChance = 0.1;
            return particle;
        }

        function createTrailParticle(x, y) {
            const particle = {};
            particle.x = x; particle.y = y;
            particle.velocityX = (Math.random() - 0.5) * 2;
            particle.velocityY = (Math.random() - 0.5) * 2;
            particle.size = Math.random() * 2.5 + 1;
            particle.color = colors[Math.floor(Math.random() * colors.length)];
            particle.gravity = 0; particle.drag = 0.92;
            particle.opacity = 0.8;
            particle.fade = Math.random() * 0.08 + 0.02;
            return particle;
        }

        function updateAndDrawParticles() {
            // --- 修改部分开始 ---
            // 为了在保留粒子拖尾效果的同时不遮挡背景图片，
            // 我们使用 'destination-out' 混合模式。
            // 这会慢慢“擦除”上一帧的内容，而不是用一个半透明颜色覆盖。
            // 这样，下方的背景画布就能透出来了。
            particleCtx.globalCompositeOperation = 'destination-out';
            particleCtx.fillStyle = 'rgba(0, 0, 0, 0.25)'; // alpha值控制拖尾的长度
            particleCtx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            // 恢复默认的混合模式，以便绘制当前帧的新粒子
            particleCtx.globalCompositeOperation = 'source-over';
            // --- 修改部分结束 ---

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.velocityX *= p.drag; p.velocityY *= p.drag;
                p.velocityY += p.gravity;
                p.x += p.velocityX; p.y += p.velocityY;
                p.opacity -= p.fade;
                if (p.isRocket && p.velocityY >= -1 && !p.exploded) {
                    p.explode(); p.exploded = true;
                }
                if (p.isCrackle && Math.random() < p.crackleChance) {
                    particles.push(createGlitterParticle(p.x, p.y));
                }
                if (p.opacity <= 0 || (p.isRocket && p.exploded)) {
                    particles.splice(i, 1);
                } else {
                    particleCtx.beginPath();
                    particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2, false);
                    particleCtx.fillStyle = p.color.startsWith('hsl') ? p.color.replace(')', `, ${p.opacity})`).replace('hsl', 'hsla') : `rgba(${hexToRgb(p.color)}, ${p.opacity})`;
                    particleCtx.fill();
                    if (p.size > 2.5) {
                        particleCtx.save();
                        particleCtx.globalCompositeOperation = 'lighter';
                        particleCtx.beginPath();
                        particleCtx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2, false);
                        particleCtx.fillStyle = p.color.startsWith('hsl') ? p.color.replace(')', `, ${p.opacity * 0.2})`).replace('hsl', 'hsla') : `rgba(${hexToRgb(p.color)}, ${p.opacity * 0.2})`;
                        particleCtx.fill();
                        particleCtx.restore();
                    }
                }
            }
            requestAnimationFrame(updateAndDrawParticles);
        }

        function hexToRgb(hex) {
            if (hex.startsWith('#')) hex = hex.slice(1);
            if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return `${r},${g},${b}`;
        }

        // --- 初始化 ---
        createStars();
        updateAndDrawParticles();

    </script>
</body>
</html>
